---
layout: post
title: JVM了解
category: Java基础
tags: Essay
keywords: 
---

### 1.JVM的构成

```
|------------------------------------JVM----------------------------------------|
|																				
| 类加载器							执行引擎                                       
|	 ||								   ||			        					
| |------------运行时数据区(JVM内存)--------------	                       	   
| | 方法区						Java栈		  	                     		  		
| |（常量池）					Native栈			<---> Native接口 <---> Native库   	   
| |																				
| |	Java堆					程序计数器										
| |--------------------------------------------								
|-------------------------------------------------------------------------------|
```

Java虚拟机（JVM）主要由类加载器、执行引擎、运行时数据区（也称JVM内存）构成；其中运行时数据区又由方法区（含常量池）、Java堆、Java栈、本地方法栈、程序计数器构成； 此外，本地方法栈还会与本地方法接口和本地库相关联。

#### 方法区(线程共享)

​		方法区是JVM中存储类信息的区域，是被线程共享的。

类信息包括：类的基本信息：类的完整名称，类的父类的完整名称，类的修饰符等。

该类的常量池：jvm会为每一个类维护一个常量池，用于存储该类需要用到的常量。
类变量：即静态变量。静态变量只有类相关，与具体实例无关，即使该类无具体实例也可以调用静态变量。
成员变量：即成员变量信息，包括名称，类型，修饰符等。
方法信息：方法逻辑、方法名、方法的返回类型、方法参数的数量和类型(有序的)和方法的修饰符。
在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。
			在方法区中，还有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。
			

#### Java堆(线程共享)

Java堆用于存放所有new出来的对象和数组，由java的内存回收机制管理堆区的对象内存分配。（引用是存放在Java栈中的）。
			堆区的对象与栈区的对象引用往往是成对的，栈区的对象引用指向堆区的对象或数组在堆内存中的首地址。
			只不过和C语言中的不同，在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。因此这部分空间也是Java垃圾收集器管理的主要区域。
			另外，堆是被所有线程共享的，在JVM中只有一个堆。堆区是所有线程共享的，这就意味着多个线程的栈区的多个引用变量，可以引用同一个堆区的对象或数组。
			

#### Java栈(线程私有)

​	Java栈也称作虚拟机栈（Java Vitual Machine Stack），Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法。栈帧保存了这个方法相关的：局部变量表、操作数栈、
​			指向运行时常量的引用、方法返回地址、附加信息。栈区用于保存基本数据类型对象和自定义对象的引用。

#### 本地方法栈(线程私有)

本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。
			

#### 程序计数器(线程私有)

虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，
			但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示 执行哪条指令的。
			由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。
			因此，可以这么说，程序计数器是每个线程所私有的。
			在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。



### 2.Java中类、对象、方法的加载过程

#### 类的加载过程

​	当Java程序需要使用某个类时，如果该类还未被加载到内存中，JVM会通过加载、连接(验证、准备和解析)、初始化三个步骤来实现该类的加载过程：
​	a.加载： 类在编译后会生成.class字节码文件, 类加载器将此字节码文件读取为二进制字节流，并存储到JVM内存的方法区中，然后将其转换为对应的java.lang.Class对象实例
​	b.连接：（a）检查：检查载入的class文件数据的正确性，包括格式和语义 （b）准备：静态变量赋默认值和存储空间，final修饰的空间赋原值 （c）解析：将符号引用转成直接引用，分配地址
​	c.初始化：(a) 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类; (b)如果类中存在静态代码块则执行，有静态变量则赋指定值。
​	
#### 对象的加载过程
​	a.检测类是否被加载：类加载了在常量池会有这个类的引用，若没加载要先加载类
​	b.在Java堆里面为创建对象分配内存：由对象头，对象数据，补位码（每个对象位数都是8的倍数，不够的需要有补位码补位）三部分组成
​	c.给各成员属性赋初值：将对象中所有非static属性赋予初值。避免构造函数没有对所有属性进行赋值。
​	d.设置对象头：虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。
​	e.执行构造函数：执行构造函数，对对象属性进行赋值。（属性先加载，方法只有调用的时候才加载）

#### 方法的加载过程
​	当第一次使用类时，JVM会通过类加载器加载类，从而初始化静态属性，并装入类的方法，包括静态方法和实例方法（方法不会被调用，只是加载，从这个意义上来说，静态方法和实例方法是类似的）
​	程序运行时会加载类编译生成的字节码，这个过程中静态变量（类变量）和静态方法及普通方法对应的字节码加载到方法区。
​	与类变量不同，方法（静态方法与实例方法）在内存中只有一份，无论该类有多少个实例，都共用一个方法

#### 总结
1.静态的东西和非静态的东西是不同时候加载的
2.总是先加载父类的，再加载子类的
3.需要用到类时加载类：加载类时，静态的属性和代码块也加载了，编写顺序决定不同静态属性和静态代码块的加载顺序
4.创建对象时加载对象：加载对象时，成员变量和非静态代码块会进行加载，他们也是按编写顺序加载的，他们加载好了才加载构造函数
5.子类和父类的方法只有调用才会加载。

#### 相关问题思考

为什么用静态内部类实现单例模式不会像饿汉模式那样有浪费空间的风险？（内部类的延迟加载机制）