---
layout: post
title: 关于Android内存泄漏
category: Android进阶
tags: Essay
keywords: 
---



### 什么是内存泄露？

> 背景：JVM引入了垃圾回收机制，垃圾回收器会自动回收不再使用的对象。垃圾回收机制是使用引用计数法和可达性分析算法来判断对象是否是不再使用的，其本质是判断一个对象是否被引用。问题：会出现这样的情形——一些对象其实不再使用应该回收的，但代码原因造成对象还在被引用，JVM误以为此对象不是垃圾不会回收，造成内存空间的浪费和侵蚀。这就是内存泄漏。

### Android中常见的内存泄漏有哪些？

#### 场景一：长生命周期的对象持有短生命周期对象的引用造成的内存泄漏

长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。

例如：Activity注册了某个服务端的监听但是退出时没有取消注册，如果此服务端生命周期较长，那么它一直持有Activity监听器的引用，从而监听器不会被回收，造成内存泄漏。（需要确保回调立即被当作垃圾回收的最佳方法是只保存他的弱引用，例如将他们保存成为WeakHashMap中的键）

又例如：生命周期较长的集合类（比如静态集合类）做缓存容器，如果业务周期结束时不再使用缓存过的内容却没有清缓存，那么容器里使用过的对象都被容器持有引用而不会被回收，此时也会造成内存泄漏。（对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值）

#### 场景二：非静态内部类造成的内存泄漏。

Java中非静态内部类依赖着外部类实例才能创建，非静态内部类持有外部类实例的引用。此种情形下即便外部类退出了，但由于内部类持有外部类的实例对象，这个外部类实例将不会被垃圾回收，从而造成内存泄露。

例如：Activity里面声明一个非静态的Handler内部类，Activity退出时，如果消息队列中有未处理的消息或者正在处理的消息，因为消息队列中的message 持有handler的引用，而handler又持有Activity的引用，所以Activity不会被回收，从而造成泄漏。

```
Activity的泄漏时很严重的，要注意以下几方面：
1.Activity绑定服务、注册监听、注册动态广播等情形时，退出前一定记得解绑或注销。
2.不要随便传Activity的上下文对象，比如一些单例需要Context构造时，最好传Application的上下文。
3.Activity里使用Handler最好用静态的内部类，而且退出时可以调用相关方法清队列。
4.与3类似，Activity退出时要记得释放一些资源，比如动画资源。
如果不在页面结束的时候释放掉属性动画，就会引起内存泄露。简单的说就是ValueAnimator在AnimationHandler注册自己的AnimationFrameCallback，AnimationFrameCallback接口的实现类就是ValueAnimator自己，ValueAnimator又持有view对象，view有持有activity对象，这样activity对象就是被引用的，所以无法被回收。这样就造成了内存泄露。
```



#### 场景三：变量作用域不合理造成的内存泄漏

一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。

例如：明明一个变量只在某个方法内起作用可以用局部变量搞定，却定义成了成员变量，就会造成一定的内存泄漏。（可以用及时设为null的方式平衡业务需求与内存泄漏风险）



#### 场景四：资源连接未及时关闭造成的内存泄漏

资源连接使用后未及时关闭或调用相关回收方法，会造成内存泄漏，比如数据库连接、网络连接、IO连接、图片动画资源等；这些资源在进行读写操作时通常都使用了缓冲，如果不及时关闭，这些缓冲对象就得不到及时释放，以致发生内存泄露。Bitmap，File，Cursor，Stream，Connection，Statement，ResultSet等类使用时都要注意。

例如：在程序中我们经常会进行查询数据库的操作，但时常会存在不小心使用Cursor之后没有及时关闭的情况。这些Cursor的泄露，反复多次出现的话会对内存管理产生很大的负面影响，我们需要谨记对Cursor对象的及时关闭。

又例如：Bitmap对象使用后没有调用recycle()释放内存造成泄漏。

#### 场景五：改变HashSet集合元素的哈希值

当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。





